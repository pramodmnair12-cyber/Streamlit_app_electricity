import streamlit as st
import pandas as pd
import io

# --- Configuration for Billing File Types ---
# This dictionary maps the specific column names for each file type
BILLING_CONFIG = {
    "Quarterly Billing": {
        "header_row": 1,
        "col_nmi": "NMI",
        "col_peak_start": "PEAK_KWH",
        "col_peak_end": "PEAK_KWH.1",      # Pandas adds .1 to the second duplicate column name
        "col_avail": "Availability charge Quantity"
    },
    "Power Smart Billing": {
        "header_row": 1,
        "col_nmi": "NMI",
        "col_peak_start": "Peak kWh reading",
        "col_peak_end": "Peak kWh reading.1",
        "col_avail": "Availability"
    },
    "Load Smart Billing": {
        "header_row": 1,
        "col_nmi": "NMI",
        "col_peak_start": "Peak kWh reading",
        "col_peak_end": "Peak kWh reading.1",
        "col_avail": "Availability"
    }
}

def process_meter_readings(billing_file, readings_file, billing_type):
    config = BILLING_CONFIG[billing_type]
    
    # 1. Load the Billing Data
    try:
        df_billing = pd.read_csv(billing_file, header=config["header_row"])
    except Exception as e:
        return None, f"Error reading billing file: {e}"

    # Verify columns exist
    required_cols = [config["col_nmi"], config["col_peak_start"], config["col_avail"]]
    # Note: col_peak_end might be auto-generated by pandas as .1, so we check loosely
    missing = [c for c in required_cols if c not in df_billing.columns]
    
    if missing:
        # Check if maybe the .1 column is missing (only for Peak End)
        if config["col_peak_end"] not in df_billing.columns:
            missing.append(config["col_peak_end"])
        return None, f"The uploaded file matches '{billing_type}' but is missing columns: {missing}. Please check the file format."

    # 2. Load the Readings File
    try:
        df_target = pd.read_csv(readings_file)
    except:
        try:
            df_target = pd.read_excel(readings_file)
        except Exception as e:
            return None, f"Error reading target file: {e}"

    # 3. Build Lookup Dictionary
    billing_lookup = {}

    for index, row in df_billing.iterrows():
        raw_nmi = row[config["col_nmi"]]
        if pd.isna(raw_nmi):
            continue
        
        # Clean NMI (remove .0 if float)
        nmi_str = str(raw_nmi)
        if nmi_str.endswith('.0'):
            nmi_str = nmi_str[:-2]
            
        billing_lookup[nmi_str] = {
            'Peak_Start': row.get(config["col_peak_start"]),
            'Peak_End': row.get(config["col_peak_end"]),
            'Avail_Qty': row.get(config["col_avail"])
        }

    # 4. Update the Target DataFrame
    matches_found = 0
    
    # Ensure columns exist
    if 'Reading From' not in df_target.columns:
        df_target['Reading From'] = None
    if 'Reading To' not in df_target.columns:
        df_target['Reading To'] = None
        
    for index, row in df_target.iterrows():
        meter_no = str(row['Meter No.'])
        
        if len(meter_no) < 2:
            continue
            
        suffix = meter_no[-1]
        nmi_base = meter_no[:-1]
        
        if nmi_base in billing_lookup:
            data = billing_lookup[nmi_base]
            
            if suffix == 'P': # Peak Cost
                p_start = data['Peak_Start']
                p_end = data['Peak_End']
                
                if pd.notna(p_start):
                    df_target.at[index, 'Reading From'] = p_start
                    matches_found += 1
                if pd.notna(p_end):
                    df_target.at[index, 'Reading To'] = p_end
                    
            elif suffix == 'A': # Availability
                avail_qty = data['Avail_Qty']
                
                if pd.notna(avail_qty):
                    df_target.at[index, 'Reading From'] = 0
                    df_target.at[index, 'Reading To'] = avail_qty
                    matches_found += 1

    return df_target, matches_found

# --- Streamlit UI Layout ---
st.set_page_config(page_title="Meter Reading Populator")

st.title("âš¡ Meter Reading Populator")
st.markdown("""
This tool populates the **Reading From** and **Reading To** columns in your Meter Readings file.
Supports **Quarterly**, **Power Smart**, and **Load Smart** billing formats.
""")

st.divider()

# Step 1: Select Type
st.subheader("1. Select Billing Type")
billing_type = st.selectbox(
    "Choose the format of your billing file:",
    list(BILLING_CONFIG.keys())
)

col1, col2 = st.columns(2)

with col1:
    st.subheader("2. Upload Billing File")
    billing_file = st.file_uploader("Upload Billing CSV", type=['csv'])

with col2:
    st.subheader("3. Upload Target File")
    readings_file = st.file_uploader("Upload Meter Readings File", type=['csv', 'xlsx'])

if billing_file and readings_file:
    st.divider()
    if st.button("Populate Readings", type="primary"):
        with st.spinner("Processing data..."):
            try:
                result_df, count_or_error = process_meter_readings(billing_file, readings_file, billing_type)
                
                if result_df is None:
                    st.error(count_or_error)
                else:
                    st.success(f"Success! Updated {count_or_error} entries.")
                    
                    st.subheader("Preview")
                    st.dataframe(result_df[['Meter No.', 'Reading From', 'Reading To']].head(10))
                    
                    csv = result_df.to_csv(index=False).encode('utf-8')
                    st.download_button(
                        label="Download Populated File",
                        data=csv,
                        file_name="Populated_Meter_Readings.csv",
                        mime="text/csv",
                    )
            except Exception as e:
                st.error(f"An error occurred: {e}")
